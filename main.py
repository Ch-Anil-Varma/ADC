import discord
from discord.ext import commands, tasks
from discord import ui
import os
import google.generativeai as genai
import asyncio
import json
from datetime import datetime, timedelta
from dotenv import load_dotenv
from pymongo import MongoClient
from keep_alive import keep_alive

# --- Setup ---
load_dotenv()
TOKEN = os.getenv("TOKEN")
MONGO_URL = os.getenv("MONGO_URL")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY") 

# --- Database ---
cluster = MongoClient(MONGO_URL)
db = cluster["CollegeBot"]
questions_col = db["questions"]
submissions_col = db["submissions"]
users_col = db["users"]

# --- Global Cache for Timers ---
attempt_timers = {}

# --- AI Setup ---
genai.configure(api_key=GEMINI_API_KEY)
model = genai.GenerativeModel('gemini-1.5-flash', generation_config={"response_mime_type": "application/json"})

intents = discord.Intents.all()
bot = commands.Bot(command_prefix="!", intents=intents)

# --- CONFIGURATION ---
LECTURER_ROLE_NAME = "Lecturer"
STUDENT_ROLE_NAME = "Student"
QUESTIONS_CHANNEL_ID = 1466759973324329007
LEADERBOARD_CHANNEL_ID = 1466759973324329008

# --- Helper: Grade with AI (Anti-Cheat Mode) ---
async def grade_submission(title, desc, code, lang):
    prompt = f"""
    Role: Computer Science Professor & Plagiarism Detector.
    
    Task 1: Grade this student's code.
    Task 2: Analyze if this code was likely generated by an AI (ChatGPT/Gemini).
    
    Look for AI Signs:
    - Explanatory text like "Here is the code" or "I hope this helps".
    - Overly perfect comments for simple logic.
    - Usage of advanced libraries not needed for the problem.
    
    Question: {title}
    Desc: {desc}
    Language: {lang}
    Code:
    {code}

    OUTPUT JSON:
    {{
        "score": (0-100),
        "feedback": "(Short feedback)",
        "status": "Pass",
        "is_ai_suspected": (true/false)
    }}
    """
    try:
        response = await model.generate_content_async(prompt)
        return json.loads(response.text)
    except:
        return {"score": 0, "feedback": "AI Error.", "status": "Fail", "is_ai_suspected": False}

# --- Helper: Update Live Leaderboard ---
async def update_live_leaderboard(question_id, guild):
    question_data = questions_col.find_one({"_id": question_id})
    if not question_data or "leaderboard_msg_id" not in question_data:
        return

    # Sort by Score (High), then Duration (Fast)
    subs = list(submissions_col.find({"question_id": question_id}).sort([("score", -1), ("duration_seconds", 1)]))

    desc = f"**Problem:** {question_data['title']}\n**Submissions:** {len(subs)}\n\n"
    
    if not subs:
        desc += "Waiting for submissions... üïí"
    else:
        for i, sub in enumerate(subs, 1):
            user = guild.get_member(sub["user_id"])
            username = user.display_name if user else "Unknown"
            
            minutes = int(sub['duration_seconds'] // 60)
            seconds = int(sub['duration_seconds'] % 60)
            time_str = f"{minutes}m {seconds}s"
            
            medal = "ü•á" if i == 1 else "ü•à" if i == 2 else "ü•â" if i == 3 else "üë§"
            desc += f"{medal} **{username}** ‚Äî {sub['score']} pts ({time_str})\n"

    embed = discord.Embed(title=f"üìä Live Leaderboard: {question_data['title']}", description=desc, color=discord.Color.gold())
    embed.set_footer(text="Ranked by Score, then Speed.")

    channel = bot.get_channel(LEADERBOARD_CHANNEL_ID)
    if channel:
        try:
            msg = await channel.fetch_message(question_data["leaderboard_msg_id"])
            await msg.edit(embed=embed)
        except:
            pass

# --- UI: Code Submission Modal ---
class CodeModal(ui.Modal, title="Submit Your Code"):
    code_input = ui.TextInput(label="Paste Code Here", style=discord.TextStyle.paragraph, height=300)

    def __init__(self, language, question_id, title, desc):
        super().__init__()
        self.language = language
        self.question_id = question_id
        self.title = title
        self.desc = desc

    async def on_submit(self, interaction: discord.Interaction):
        # --- CHEAT SHIELD LAYER 1: THE TIMER ---
        timer_key = f"{interaction.user.id}_{self.question_id}"
        start_time = attempt_timers.get(timer_key)
        
        duration = 0
        if start_time:
            duration = (datetime.utcnow() - start_time).total_seconds()
            if timer_key in attempt_timers:
                del attempt_timers[timer_key]

        # REJECT if typed in less than 15 seconds
        if duration < 15:
            await interaction.response.send_message("‚ùå **Submission Rejected!**\nYou answered too fast (under 15s). Please type the code manually.", ephemeral=True)
            return

        # --- CHEAT SHIELD LAYER 2: SLOPPY PASTE FILTER ---
        banned_phrases = ["here is the code", "as an ai", "hope this helps", "usage:", "explanation:"]
        if any(phrase in self.code_input.value.lower() for phrase in banned_phrases):
             await interaction.response.send_message("‚ùå **Submission Rejected!**\nYour code contains AI conversational text. Please submit ONLY the code.", ephemeral=True)
             return

        # Check Duplicates
        if submissions_col.find_one({"user_id": interaction.user.id, "question_id": self.question_id}):
            await interaction.response.send_message("‚ùå Already submitted!", ephemeral=True)
            return

        await interaction.response.defer(thinking=True, ephemeral=True)

        # --- CHEAT SHIELD LAYER 3: THE AI DETECTIVE ---
        result = await grade_submission(self.title, self.desc, self.code_input.value, self.language)
        
        score = result.get("score", 0)
        feedback = result.get("feedback", "No feedback.")
        is_ai_suspected = result.get("is_ai_suspected", False)

        # PENALTY LOGIC
        if is_ai_suspected:
            score = 0
            feedback = "‚ö†Ô∏è **AI Detection Alert:** Your code style strongly resembles AI generation. Score reduced to 0."

        # Save to DB (Optimized: Code text NOT saved)
        submissions_col.insert_one({
            "user_id": interaction.user.id,
            "question_id": self.question_id,
            "score": score,
            "feedback": feedback,
            "language": self.language,
            "duration_seconds": duration,
            "is_ai_flagged": is_ai_suspected,
            "timestamp": datetime.utcnow()
        })

        if score > 0:
            users_col.update_one({"_id": interaction.user.id}, {"$inc": {"score": score}}, upsert=True)

        # Send Result
        color = discord.Color.green() if score >= 50 else discord.Color.red()
        if is_ai_suspected: color = discord.Color.orange()

        mins = int(duration // 60)
        secs = int(duration % 60)
        
        embed = discord.Embed(title=f"Result: {score}/100", color=color)
        embed.add_field(name="‚è±Ô∏è Time Taken", value=f"{mins}m {secs}s", inline=True)
        embed.add_field(name="Feedback", value=feedback, inline=False)
        
        await interaction.followup.send(embed=embed, ephemeral=True)

        # Only update leaderboard if not cheating
        if not is_ai_suspected:
            await update_live_leaderboard(self.question_id, interaction.guild)

# --- UI: Language Select ---
class LanguageSelect(ui.Select):
    def __init__(self, q_id, title, desc):
        options = [
            discord.SelectOption(label="Python", value="Python", emoji="üêç"),
            discord.SelectOption(label="JavaScript", value="JavaScript", emoji="üìú"),
            discord.SelectOption(label="C++", value="C++", emoji="‚öôÔ∏è"),
            discord.SelectOption(label="Java", value="Java", emoji="‚òï"),
        ]
        super().__init__(placeholder="Select Language & Start Timer...", options=options)
        self.q_id = q_id
        self.title = title
        self.desc = desc

    async def callback(self, interaction: discord.Interaction):
        # Start Timer
        attempt_timers[f"{interaction.user.id}_{self.q_id}"] = datetime.utcnow()

        q_data = questions_col.find_one({"_id": self.q_id})
        if not q_data or not q_data.get("active", False):
            await interaction.response.send_message("‚ùå Closed!", ephemeral=True)
            return
            
        await interaction.response.send_modal(CodeModal(self.values[0], self.q_id, self.title, self.desc))

class QuestionView(ui.View):
    def __init__(self, q_id, title, desc):
        super().__init__(timeout=None)
        self.add_item(LanguageSelect(q_id, title, desc))

# --- Bot Events ---
@bot.event
async def on_ready():
    keep_alive()
    print(f"‚úÖ Logged in as {bot.user}")

@bot.command()
@commands.has_role(LECTURER_ROLE_NAME)
async def post(ctx, *, args):
    try:
        parts = args.split('|')
        title = parts[0].strip()
        description = parts[1].strip()
    except:
        await ctx.send("‚ùå Usage: `!post Title | Description`")
        return

    # Deactivate old questions
    questions_col.update_many({"active": True}, {"$set": {"active": False}})

    question_id = str(ctx.message.id)
    
    lb_channel = bot.get_channel(LEADERBOARD_CHANNEL_ID)
    leaderboard_msg = None
    if lb_channel:
        initial_embed = discord.Embed(
            title=f"üìä Live Leaderboard: {title}", 
            description="Waiting for submissions... üïí", 
            color=discord.Color.gold()
        )
        leaderboard_msg = await lb_channel.send(embed=initial_embed)

    questions_col.insert_one({
        "_id": question_id,
        "title": title,
        "description": description,
        "active": True,
        "leaderboard_msg_id": leaderboard_msg.id if leaderboard_msg else None,
        "timestamp": datetime.utcnow()
    })

    q_channel = bot.get_channel(QUESTIONS_CHANNEL_ID)
    role = discord.utils.get(ctx.guild.roles, name=STUDENT_ROLE_NAME)
    
    embed = discord.Embed(title=f"üì¢ New Challenge: {title}", description=description, color=discord.Color.blue())
    embed.add_field(name="‚ö†Ô∏è Anti-Cheat Active", value="Time Limit: 24h\nAI Detection: ON\nSpeed Trap: ON", inline=False)
    embed.set_footer(text="Select language to start timer. Don't copy-paste!")

    if q_channel:
        await q_channel.send(content=f"{role.mention}", embed=embed, view=QuestionView(question_id, title, description))
        
    await ctx.message.delete()

@bot.command()
async def global_leaderboard(ctx):
    top_users = users_col.find().sort("score", -1).limit(10)
    desc = ""
    for i, user_data in enumerate(top_users, 1):
        user = ctx.guild.get_member(user_data["_id"])
        name = user.display_name if user else "Unknown"
        desc += f"**{i}.** {name} ‚Äî {user_data['score']} pts\n"
    
    embed = discord.Embed(title="üèÜ Hall of Fame", description=desc, color=discord.Color.purple())
    await ctx.send(embed=embed)

bot.run(TOKEN)